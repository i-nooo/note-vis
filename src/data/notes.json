{
  "nodes": [
    {
      "id": "HOC",
      "title": "고차 컴포넌트 (HOC)",
      "tags": ["react"],
      "content": "React에서 컴포넌트를 재사용 가능한 로직으로 추상화하기 위한 패턴으로, 새로운 기능을 추가하거나 기존 동작을 확장하기 위해 컴포넌트를 입력으로 받아 다른 컴포넌트를 반환하는 함수\n\n고차 함수는 아래 방식들을 통해 재사용 및 관심사 분리 패턴으로 작동된다.\n\n- props 주입\n- 조건부 렌더링\n- 로직 공유",
      "dateUpdated": "2025-09-10"
    },
    {
      "id": "base-router-설정",
      "title": "base router 설정",
      "tags": ["BUGFIX", "react", "tanstack-router"],
      "content": "<br/>\n\n> [!NOTE]+ 환경\n>\n> \\- React 19\n> \\- Vite\n> \\- Tanstack Router\n> \\- Vercel\n\n<br/>\n\nSPA 환경에서 TanStack Router를 사용하여 애플리케이션을 개발하던 중, 브라우저 주소창에 /myapp/xxx 와 같은 서브 경로를 직접 입력하면 404 오류가 발생하는 것을 확인하였습니다. 그러나 라우터 링크를 통해 내부 페이지로 이동하는 것은 정상적으로 동작하였습니다. 네트워크 요청을 확인해본 결과, 브라우저가 해당 경로에 실제 정적 파일이 존재하는지 확인하다가 찾지 못해 404를 반환하고 있음을 알게 되었습니다.\n\n<br/>\n\n공식 문서(TanStack Router Docs, Vercel Rewrites)를 참고한 결과, SPA는 최초에 index.html을 로드한 뒤 클라이언트 라우터가 동작하기 때문에, 서버(또는 호스팅 플랫폼)에서 존재하지 않는 경로로의 요청을 index.html로 리라이트해야 함을 알게 되었습니다. 또한 애플리케이션을 루트가 아닌 /myapp 경로에 배포했기 때문에, 라우터 basepath와 빌드 경로 설정도 일관되게 맞추어야 함을 확인하였습니다.\n\n<br/><br/>\n\n이를 해결하기 위해 다음과 같이 수정하였습니다.\n\n<br/>\n\n1. TanStack Router basepath 지정\n\n```ts\nimport { createRouter } from '@tanstack/react-router'\n\nconst router = createRouter({\n  routeTree,\n  basepath: '/myapp',\n})\n```\n\n→ 라우터가 /myapp을 기준으로 경로를 인식하도록 수정하였습니다.\n\n<br/>\n\n2. Vite 설정 수정\n\n```ts\n// vite.config.ts\nexport default defineConfig({\n  base: '/myapp/',\n})\n```\n\n→ 빌드된 정적 자산(js, css 등)이 올바른 경로에서 로드되도록 하였습니다.\n\n<br/>\n\n3. Vercel 리라이트 설정 추가\n\n```json\n// vercel.json\n{\n  \"rewrites\": [\n    {\n      \"source\": \"/myapp/(.*)\",\n      \"destination\": \"/myapp/index.html\"\n    }\n  ]\n}\n```\n\n→ /myapp 이하의 모든 경로를 index.html로 전달하도록 하였습니다.\n\n<br/><br/>\n\n이 과정을 거친 후 브라우저 주소창에 /myapp/xxx 와 같은 경로를 직접 입력해도 Vercel이 index.html을 반환하게 되었고, TanStack Router가 정상적으로 초기화되어 해당 경로를 매칭할 수 있었습니다. 결과적으로 내부 링크 이동과 직접 주소 입력이 동일하게 동작하는 일관된 라우팅 경험을 제공할 수 있었습니다.\n\n<br/>\n\n이번 경험을 통해 CSR 기반 라우팅에서는 배포 환경에 맞는 index.html fallback 설정이 필수적임을 학습하였습니다. 특히 Vercel과 같은 정적 호스팅 환경에서는 vercel.json의 rewrite 규칙을 통해 라우팅 문제를 해결할 수 있음을 확인하였습니다. 또한 애플리케이션을 서브 경로에 배포할 경우 라우터 basepath, 빌드 base 설정, 호스팅 플랫폼의 리라이트 규칙을 반드시 일관되게 구성해야 함을 깨달았습니다.",
      "dateCreated": "2025-09-04"
    },
    {
      "id": "flex",
      "title": "flex",
      "tags": ["css"],
      "content": "> Flexbox(CSS Flexible Box Layout Module) 에서 아이템 단위에 적용되는 단축 속성\n\n<br/>\n\nFlexbox는 레이아웃 전체 시스템을 의미하며, 컨테이너와 그 안의 아이템들이 공간을 배치·정렬·분배하는 방식에 대한 큰 틀의 규칙과 개념이다.\n\n- 컨테이너 속성\n  - display: flex\n  - flex-direction\n  - justify-content\n  - aling-items\n  - flex-wrap 등\n- 아이템 속성\n  - _flex-grow_\n  - _flex-shrink_\n  - _flex-basis_\n  - align-self\n  - order 등\n\n<br/>\n\n여기서 아이템용 속성 중 flex는 **아이템의 크기를 어떻게 분배하고, 공간이 부족하거나 남을 때 어떻게 행동할지 결정하는 것**으로, 단축 속성으로도 작성할 수 있다.\n\n```css\nflex: <flex-grow> <flex-shrink> <flex-basis>;\n```\n\n<br/>\n\n1. **flex-grow**\n   - 컨테이너 안에 남는 공간이 있으면, 각 아이템의 flex-grow 값에 따라 분배된다.\n   - 기본값: 0 (남는 공간을 차지하지 않음)\n     - 1: 동일한 비율로 남는 공간 분배\n     - n: 값이 1인 요소보다 n 배 더 많이 차지\n\n   ```css\n   .item1 {\n     flex-grow: 1;\n   }\n   .item2 {\n     flex-grow: 2;\n   }\n   ```\n\n   컨테이너 여유 공간이 300px 라면, item1은 100px, item2는 200px 를 추가로 갖는다.\n\n<br/>\n\n2. **flex-shrink**\n\n- 컨테이너가 좁아지면 각 아이템이 flex-shrink 값 비율만큼 줄어든다.\n- 기본값: 1 (줄어든다)\n  - 0: 줄어들지 않는다.\n  - n: 1인 다른 요소보다 n배 더 빨리 줄어든다.\n\n  ```css\n  .item1 {\n    flex-shrink: 1;\n  }\n  .item2 {\n    flex-shrink: 0;\n  }\n  ```\n\n  컨테이너 공간이 부족해지면 item1은 줄어들고, item2는 줄어들지 않는다.\n\n<br/>\n\n3. **flex-basis**\n\n- grow/shrink 연산이 적용되기 전에 아이템의 기준 크기를 설정한다.\n- 기본값: auto (아이템에 정의된 width, height를 따른다)\n  - n px, %: 이 지정 크기에서 출발한다. 이후 grow, shrink 규칙이 적용된다.\n\n```css\n.item {\n  flex-basis: 150px;\n  flex-grow: 1;\n}\n```\n\n기본 크기는 150px, 컨테이너에 여유 공간이 있으면 추가로 확장된다.",
      "dateCreated": "2025-09-11",
      "dateUpdated": "2025-09-15"
    },
    {
      "id": "god-object",
      "title": "God Object",
      "tags": ["pattern", "anti", "code-smell"],
      "content": "[[단일 책임 원칙(SRP)]]에 반하는 안티패턴으로, 특정 클래스나 객체가 과도하게 많은 책임과 기능을 떠맡아, 마치 모든 것을 통제하는 신처럼 시스템 전반에 관여하는 상황을 가리킨다.\n\n이 경우, 한 객체에 지나치게 많은 데이터와 로직이 몰려 있어, 프로젝트가 커질수록 이 객체는 점점 비대해지고, 수정이나 확장 시 다른 부분까지 연쇄적으로 영향을 미친다. 이는 코드 이해도를 저하시킬 뿐만 아니라, 팀 생산성을 저해하며, 버그 발생 가능성을 높이는 구조적 문제를 야기한다. 또한 복잡한 의존성으로 인해 단위 테스트 및 재사용도 어려워진다.\n\n<br/>\n\n이런 상황을 피하기 위해선 다음과 같은 접근이 필요하다:\n\n- **단일 책임 원칙을 준수**하여, 클래스마다 한 가지 역할만을 담당하도록 하고\n- 데이터 접근, 비즈니스 로직, 프레젠테이션 레이어 분리를 통해 **레이어드 아키텍처를 적용**한다.\n- 혹은 전략 패턴, 옵저버 패턴, 리포지토리 **패턴 등을 적용**해 역할을 분산시킨다.\n\n<br/>\n\n---\n\n<br/>\n\n### 참고\n\n- [Yak Shaving: 야크 털 깎기:티스토리](https://nodiscard.tistory.com/381)",
      "dateCreated": "2025-09-15",
      "dateUpdated": "2025-09-15"
    },
    {
      "id": "react-memo",
      "title": "React.memo",
      "tags": ["react", "불변성"],
      "content": "React.memo는 React에서 함수형 컴포넌트의 불필요한 리렌더링을 방지하기 위한 고차 컴포넌트(HOC)이다.\n\nReact.memo는 얕은 비교(shallow comparison) 를 통해 이전 props와 새 props가 동일하면 리렌더링을 건너뛴다.\n\n즉, 동일한 props가 들어오면 컴포넌트를 **다시 렌더링하지 않고 이전에 렌더링된 결과를 재사용**한다.\n\n다만,\n\n- 얕은 비교 한계: React.memo는 props 객체를 얕게 비교하기 때문에, 객체나 배열 같은 참조 타입이 매번 새로 만들어지면 매번 다르다고 판단한다. 이 경우 [[useMemo|useMemo]]나 [[useCallback]]으로 안정된 참조를 제공해야 한다.\n- 모든 경우에 성능 향상 X: React.memo 자체도 비교 연산 비용이 있기 때문에, 단순한 컴포넌트에는 오히려 성능 이득이 없다. 렌더링 비용이 큰 컴포넌트에 적용하는 것이 적절하다.",
      "dateCreated": "2025-09-10"
    },
    {
      "id": "web-browser-engineering",
      "title": "웹 브라우저 엔지니어링",
      "tags": ["web", "web-rendering"],
      "content": "> [웹 브라우저 엔지니어링](https://browser.engineering/intro.html) 을 읽으며 정리한 문서 모음\n\n<br/>\n\n## INTRO\n\n- [[선언적-웹-아키텍처|선언적 웹 아키텍처]]\n\n<br/>\n\n## PART 1: Loading Pages\n\n- [[웹-페이지-다운로드|웹 페이지 다운로드]]",
      "dateCreated": "2025-09-11",
      "dateUpdated": "2025-09-11"
    },
    {
      "id": "배열-튜플-딕셔너리",
      "title": "배열, 튜플, 딕셔너리",
      "tags": ["python"],
      "content": "**배열**\n\n- arr=[]\n- arr=[1, 2, 3, 4]\n- arr[0]\n\n<br/>\n\n**튜플**\n\n- tup=()\n- tup=(1,2,3,4)\n- tup=[0]\n- 생성 후 값 삭제, 변경 불가\n\n<br/>\n\n**딕셔너리**\n\n- dic={}\n- dic{\"a\":1, \"b\":2, \"c\":3}\n- dic[\"1\"]\n- key값 사용하여 값 접근\n- 중복 key 불가",
      "dateCreated": "2025-09-23",
      "dateUpdated": "2025-09-23"
    },
    {
      "id": "블로그-마크다운-문법",
      "title": "블로그 마크다운 문법",
      "tags": ["memo"],
      "content": "# 문법\n\n<br/>\n\n- 테스트1\n  - 테스트2\n\n<br/>\n\n> [!NOTE] -\n>\n> 콜아웃\n> !NOTE, !INFO\n\n<br/>\n\n각주[^1]\n\n[^1]: 각주 입니다.",
      "dateCreated": "2025-09-11",
      "dateUpdated": "2026-01-16"
    },
    {
      "id": "선언적-웹-아키텍처",
      "title": "선언적 웹 아키텍쳐",
      "tags": ["web", "페러다임"],
      "content": "> 출처: [웹 브라우저 엔지니어링](https://browser.engineering/intro.html)\n\n<br/>\n\n- 웹은 하이퍼링크로 연결된 정보의 네트워크이다.\n- 사용자는 브라우저 라고 하는 사용자 에이전트를 사용하여 웹을 탐색한다.\n- 정보는 HTTP(HyperText Transfer Protocol)를 통해 요청되고 HTML 문서 형식으로 구조화됩니다 .\n- 문서는 내용이 아닌 URL(Uniform Resource Locator)로 식별되며 동적으로 생성될 있다.\n- 웹 페이지는 이미지, 비디오, CSS(Cascading Style Sheets), JavaScript를 포함한 다양한 형식의 보조 자산에 링크할 수 있다.\n- 이러한 모든 구성 요소는 개방적이고 표준화되어 있으며 무료로 사용하거나 재사용할 수 있다.\n\n<br/>\n\n웹 브라우저의 동작을 가능하게 하는 핵심은 **제어의 역전(inversion of control)**, **제약 프로그래밍(constraint programming)**, 그리고 **선언적 프로그래밍(declarative programming)** 의 구현에 있다.\n\n> [!NOTE] -\n> **제어의 역전**\n>\n> 일반적으로 전통적 프로그래밍은 개발자가 “순서대로” 동작을 직접 제어하지만, 하지만 웹에서는 브라우저가 중심이 되어 렌더링, 이벤트 처리, 동기화 등을 맡고, 개발자는 선언적으로 지시만 한다. 웹 브라우저는 거대한 프레임워크라고 볼 수 있다.\n> \\\n> **제약 프로그래밍**\n>\n> 웹 레이아웃은 절대 좌표 기반이 아니라, “이 요소는 저 요소 옆에 있어야 한다”, “이 너비는 부모의 50%여야 한다” 같은 제약식으로 표현된다. (flexbox, grid)\n> \\\n> **선언적 프로그래밍**\n>\n> 개발자는 무엇을 원한다만 기술한다. 어떻게 실행되는가는 브라우저가 책임진다. DOM 변경, CSS 속성 변경 → 개발자는 “적용된다”고 본다. 하지만 실제 반영 시점은 브라우저의 최적화 루틴에 따라 지연될 수 있다. 선언적 스타일 덕분에 개발자의 관점에서는 변화가 “즉시 적용되는 것처럼” 보이지만, 내부적으로 브라우저는 게으른(lazy) 방식으로 동작하여, 후속 API 호출이나 실제 화면 표시가 필요할 때까지 적용을 지연시킬 수 있다. 이는 성능 최적화(레이아웃 병합, repaint 지연 등)를 가능하게 한다.\n\n<br/>\n\n웹 브라우저를 단순히 “표시 도구”로 보지 않고, 제약 해결기(constraint solver) + 이벤트 루프 + 선언적 실행 환경이라는 큰 소프트웨어 아키텍처로 이해해야 한다.\n\n<br/>\n\nQ. 이 세 가지(제어 역전, 제약 프로그래밍, 선언적 프로그래밍)가 프론트엔드 프레임워크(React, Vue, Svelte 등)에 어떻게 계승·확장되었는지",
      "dateCreated": "2025-09-08",
      "dateUpdated": "2025-09-08"
    },
    {
      "id": "전역-상태-관리-라이브러리들",
      "title": "전역 상태관리 라이브러리 비교 (Redux, Tanstack Store, Zustand, Recoil)",
      "tags": ["react", "state-managemnet"],
      "content": "상태 관리 라이브러리에 처음 입문한 것은 Redux였다. 당시에는 구조가 너무 복잡해 직접 그림을 그려가며 공부했던 기억이 있다. 이후 상태 관리 개념에 어느 정도 익숙해진 뒤부터는 주로 Zustand를 사용해왔다. Redux보다 초기 설정과 사용이 단순했고, 내 프로젝트에서는 무거운 상태를 다룰 일이 많지 않았기 때문에 훨씬 쾌적한 DX를 경험 할 수 있었다. Recoil도 사용했었지만, 내가 접한 시점에는 이미 deprecated 상태였기에 실질적으로는 Zustand를 주로 활용했다.\n\nTanstack Query를 알게 되고 나선, Tanstack 팀 레포지토리를 자주 들여다보고 있는데, Tanstack Store 라이브러리가 출시된 걸 보고 틈틈이 써보고 있다.\n\n리액트는 곧 상태라고 생각한다. 따라서 상태 관리가 핵심적인 주제이며, 그만큼 다양한 선택지가 존재하는 것 같다. 각 라이브러리의 철학, 장단점, 설정 방식, 활용 방법을 살펴보고 어떤 상황에서 어떤 라이브러리가 적합한지 나름의 정리를 해보고자 한다.\n\n<br/>\n\n## Redux(w. RTK)\n\n- 예측 가능하고 유지 관리 가능한 글로벌 상태 관리를 위한 JS 라이브러리\n- 예측 가능한 불변 업데이트, 단방향의 데이터 흐름, 순수 리듀서 함수\n- 상태, 액션, reducer, dispatch, store\n\n  • Flux 아키텍처와 Context API의 한계\n  • 서버 상태와 클라이언트 상태의 구분 (Tanstack Query의 철학적 기반)\n  • 상태 관리의 복잡도와 스케일에 따른 의사결정 기준\n  • React 18 이후 등장한 use 훅, 서버 컴포넌트와 상태 관리의 관계\n\n---\n\n### 참고\n\n- [Redux의 탄생동기와 철학 이해하기](https://jun-choi-4928.medium.com/redux의-탄생동기와-철학-이해하기-60eaa83e0b68)",
      "dateCreated": "2025-09-15",
      "dateUpdated": "2025-09-15"
    },
    {
      "id": "튜플을-사용하는-이유",
      "title": "튜플을 사용하는 이유",
      "tags": ["python"],
      "content": "튜플은 배열(list)과 딕셔너리(dict)와는 다른 역할과 성질을 갖는다.\n\n<br/>\n\n1. 불변성\n2. 이질적 데이터\n3. 성능 및 최적화\n4. 함수 반환값 패턴\n\n<br/>\n\n## 1. 불변성\n\n- 정의된 값은 수정이 불가능하다는 불변성 때문에 해시 가능(hashable)한 객체로 쓸 수 있다.\n- 덕분에 딕셔너리의 키나 집합의 원소로 사용할 수 있다.\n- 리스트는 불변적이지 않기 때문에 이 역할을 수행할 수 없다.\n\n<br/>\n\n## 2. 이질적 데이터 [^1]\n\n- 리스트는 동질적 데이터 집합을 다루는데 주로 쓰인다.\n  - 학생 점수 목록, 상품 ID 등\n- 반면 튜플은 이질적 데이터 구조를 표현하는데 적합하다.\n  - (이름, 나이, 직업)처럼 여러 속성이 묶인 하나의 레코드\n- 즉, 순서가 있는 불변 구조체로, 작은 데이터 구조체의 역할을 대신할 수 있다.\n\n<br/>\n\n## 3. 성능 및 최적화\n\n- 불변이라는 성질 때문에 리스트보다 메모리를 적게 쓰고, 접근 속도도 조금 더 빠르다.\n\n<br/>\n\n## 4. 함수 반환값 패턴\n\n- 함수에서 여러 값을 동시에 반환할 때 쓰이는 구조가 튜플이다.\n\n```python\ndef divide(a, b):\n    return a//b, a%b\n\n# 반환값: (a//b, a%b)\n```\n\n- 호출 시 자동으로 언패킹이 가능하여 (몫, 나머지)처럼 두 값이 명확하게 묶인다.\n\n[^1]: 동질적, 이질적: 데이터나 집단의 구성요소가 서로 같거나 다른 정도를 설명하는 개념. 이질적은 \"성질이 다른 것들로 이루어져 있다.\"를 의미한다.",
      "dateCreated": "2025-09-23",
      "dateUpdated": "2025-09-23"
    },
    {
      "id": "tag:react",
      "title": "#react"
    },
    {
      "id": "tag:BUGFIX",
      "title": "#BUGFIX"
    },
    {
      "id": "tag:tanstack-router",
      "title": "#tanstack-router"
    },
    {
      "id": "tag:css",
      "title": "#css"
    },
    {
      "id": "tag:pattern",
      "title": "#pattern"
    },
    {
      "id": "tag:anti",
      "title": "#anti"
    },
    {
      "id": "tag:code-smell",
      "title": "#code-smell"
    },
    {
      "id": "tag:불변성",
      "title": "#불변성"
    },
    {
      "id": "tag:web",
      "title": "#web"
    },
    {
      "id": "tag:web-rendering",
      "title": "#web-rendering"
    },
    {
      "id": "tag:python",
      "title": "#python"
    },
    {
      "id": "tag:memo",
      "title": "#memo"
    },
    {
      "id": "tag:페러다임",
      "title": "#페러다임"
    },
    {
      "id": "tag:state-managemnet",
      "title": "#state-managemnet"
    }
  ],
  "links": [
    {
      "source": "HOC",
      "target": "tag:react",
      "type": "tag"
    },
    {
      "source": "base-router-설정",
      "target": "tag:BUGFIX",
      "type": "tag"
    },
    {
      "source": "base-router-설정",
      "target": "tag:react",
      "type": "tag"
    },
    {
      "source": "base-router-설정",
      "target": "tag:tanstack-router",
      "type": "tag"
    },
    {
      "source": "flex",
      "target": "tag:css",
      "type": "tag"
    },
    {
      "source": "god-object",
      "target": "단일 책임 원칙(SRP)",
      "type": "mention",
      "broken": true
    },
    {
      "source": "god-object",
      "target": "tag:pattern",
      "type": "tag"
    },
    {
      "source": "god-object",
      "target": "tag:anti",
      "type": "tag"
    },
    {
      "source": "god-object",
      "target": "tag:code-smell",
      "type": "tag"
    },
    {
      "source": "react-memo",
      "target": "useMemo",
      "type": "mention",
      "broken": true
    },
    {
      "source": "react-memo",
      "target": "useCallback",
      "type": "mention",
      "broken": true
    },
    {
      "source": "react-memo",
      "target": "tag:react",
      "type": "tag"
    },
    {
      "source": "react-memo",
      "target": "tag:불변성",
      "type": "tag"
    },
    {
      "source": "web-browser-engineering",
      "target": "선언적-웹-아키텍처",
      "type": "mention"
    },
    {
      "source": "web-browser-engineering",
      "target": "웹-페이지-다운로드",
      "type": "mention",
      "broken": true
    },
    {
      "source": "web-browser-engineering",
      "target": "tag:web",
      "type": "tag"
    },
    {
      "source": "web-browser-engineering",
      "target": "tag:web-rendering",
      "type": "tag"
    },
    {
      "source": "배열-튜플-딕셔너리",
      "target": "tag:python",
      "type": "tag"
    },
    {
      "source": "블로그-마크다운-문법",
      "target": "tag:memo",
      "type": "tag"
    },
    {
      "source": "선언적-웹-아키텍처",
      "target": "tag:web",
      "type": "tag"
    },
    {
      "source": "선언적-웹-아키텍처",
      "target": "tag:페러다임",
      "type": "tag"
    },
    {
      "source": "전역-상태-관리-라이브러리들",
      "target": "tag:react",
      "type": "tag"
    },
    {
      "source": "전역-상태-관리-라이브러리들",
      "target": "tag:state-managemnet",
      "type": "tag"
    },
    {
      "source": "튜플을-사용하는-이유",
      "target": "tag:python",
      "type": "tag"
    }
  ]
}
