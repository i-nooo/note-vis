{
  "nodes": [
    {
      "id": "HOC",
      "title": "고차 컴포넌트 (HOC)",
      "tags": [
        "react"
      ],
      "content": "React에서 컴포넌트를 재사용 가능한 로직으로 추상화하기 위한 패턴으로, 새로운 기능을 추가하거나 기존 동작을 확장하기 위해 컴포넌트를 입력으로 받아 다른 컴포넌트를 반환하는 함수\n\n고차 함수는 아래 방식들을 통해 재사용 및 관심사 분리 패턴으로 작동된다.\n\n- props 주입\n- 조건부 렌더링\n- 로직 공유",
      "dateUpdated": "2025-09-10"
    },
    {
      "id": "HTML-preview",
      "title": "HTML preview",
      "tags": [
        "note-vis"
      ],
      "content": "본 프로젝트 내 마크다운 파일에서 HTML, CSS, JavaScript 코드를 작성하고 실시간으로 렌더링할 수 있다.\n\n## 사용 방법\n\n코드 블록에 `html-preview` 또는 `html-live` 언어를 지정한다.\n\n````markdown\n```html-preview\n<p>Hello World</p>\n```\n````\n\n---\n\n## 예제 1: 기본 HTML + CSS\n\n```html-preview\n<style>\n  .card {\n    padding: 20px;\n    border-radius: 12px;\n    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n    color: white;\n    font-family: system-ui, sans-serif;\n    text-align: center;\n  }\n  .card h2 {\n    margin: 0 0 8px 0;\n  }\n  .card p {\n    margin: 0;\n    opacity: 0.9;\n  }\n</style>\n\n<div class=\"card\">\n  <h2>카드 제목</h2>\n  <p>CSS 스타일이 적용된 카드 컴포넌트</p>\n</div>\n```\n\n---\n\n## 예제 2: CSS 애니메이션\n\n```html-preview\n<style>\n  .spinner {\n    width: 50px;\n    height: 50px;\n    border: 4px solid #f3f3f3;\n    border-top: 4px solid #3498db;\n    border-radius: 50%;\n    animation: spin 1s linear infinite;\n    margin: 20px auto;\n  }\n  @keyframes spin {\n    0% { transform: rotate(0deg); }\n    100% { transform: rotate(360deg); }\n  }\n</style>\n\n<div class=\"spinner\"></div>\n```\n\n---\n\n## 예제 3: JavaScript 인터랙션\n\n```html-preview\n<style>\n  .counter {\n    font-family: system-ui, sans-serif;\n    text-align: center;\n    padding: 20px;\n  }\n  .count {\n    font-size: 48px;\n    font-weight: bold;\n    color: #333;\n  }\n  .buttons {\n    margin-top: 16px;\n    display: flex;\n    gap: 8px;\n    justify-content: center;\n  }\n  button {\n    padding: 8px 16px;\n    font-size: 18px;\n    border: none;\n    border-radius: 6px;\n    cursor: pointer;\n    background: #4f46e5;\n    color: white;\n  }\n  button:hover {\n    background: #4338ca;\n  }\n</style>\n\n<div class=\"counter\">\n  <div class=\"count\" id=\"count\">0</div>\n  <div class=\"buttons\">\n    <button onclick=\"decrement()\">-</button>\n    <button onclick=\"increment()\">+</button>\n  </div>\n</div>\n\n<script>\n  let count = 0;\n  const countEl = document.getElementById('count');\n\n  function increment() {\n    count++;\n    countEl.textContent = count;\n  }\n\n  function decrement() {\n    count--;\n    countEl.textContent = count;\n  }\n</script>\n```\n\n---\n\n## 예제 4: Flexbox 레이아웃\n\n```html-preview\n<style>\n  .flex-container {\n    display: flex;\n    gap: 10px;\n    padding: 20px;\n    background: #f5f5f5;\n  }\n  .box {\n    width: 60px;\n    height: 60px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    font-weight: bold;\n    color: white;\n    border-radius: 8px;\n  }\n  .box:nth-child(1) { background: #ef4444; }\n  .box:nth-child(2) { background: #f59e0b; }\n  .box:nth-child(3) { background: #10b981; }\n  .box:nth-child(4) { background: #3b82f6; }\n</style>\n\n<div class=\"flex-container\">\n  <div class=\"box\">1</div>\n  <div class=\"box\">2</div>\n  <div class=\"box\">3</div>\n  <div class=\"box\">4</div>\n</div>\n```\n\n---\n\n## 보안\n\niframe의 `sandbox=\"allow-scripts\"` 속성으로 격리되어 있어 메인 페이지에 영향을 주지 않는다.\n\n- 부모 페이지 DOM 접근 불가\n- 쿠키, localStorage 접근 불가\n- 폼 제출 불가\n\n---\n\n## 구현 상세\n\n### 아키텍처 개요\n\n```\n마크다운 → marked 파서 → 커스텀 렌더러 → DOMPurify → 화면 출력\n                              ↓\n                    html-preview 감지\n                              ↓\n                    sandbox iframe 생성\n```\n\n### 1. 커스텀 코드 블록 렌더러\n\n`src/utils/markdown/renderer.ts`에서 코드 블록을 처리할 때 언어가 `html-preview` 또는 `html-live`인 경우를 감지한다.\n\n```ts\ncode({ text: code, lang }: { text: string; lang?: string }) {\n  // HTML 프리뷰 처리\n  if (lang === 'html-preview' || lang === 'html-live') {\n    return createHtmlPreview(code)\n  }\n  // ... 일반 코드 블록 처리\n}\n```\n\n### 2. iframe 생성 함수\n\n`createHtmlPreview` 함수가 sandbox iframe을 포함한 HTML 구조를 생성한다.\n\n```ts\nfunction createHtmlPreview(code: string): string {\n  const id = `html-preview-${previewIdCounter++}`\n\n  return `<div class=\"html-preview-container\">\n    <div class=\"html-preview-header\">\n      <span class=\"html-preview-label\">HTML Preview</span>\n      <button class=\"html-preview-toggle\"\n        onclick=\"this.closest('.html-preview-container').classList.toggle('show-code')\">\n        코드 보기\n      </button>\n    </div>\n    <iframe\n      id=\"${id}\"\n      class=\"html-preview-frame\"\n      sandbox=\"allow-scripts\"\n      srcdoc=\"${escapeHtml(code)}\"\n    ></iframe>\n    <pre class=\"html-preview-source\">\n      <code class=\"language-html\">${escapeHtml(code)}</code>\n    </pre>\n  </div>`\n}\n```\n\n**핵심 포인트:**\n\n| 속성 | 설명 |\n|------|------|\n| `sandbox=\"allow-scripts\"` | JS 실행은 허용하되 부모 페이지 접근 차단 |\n| `srcdoc` | iframe 내용을 인라인으로 지정 (별도 URL 불필요) |\n| `escapeHtml()` | XSS 방지를 위해 HTML 특수문자 이스케이프 |\n\n### 3. DOMPurify 설정\n\n`src/utils/markdown/constants.ts`에서 iframe 관련 태그와 속성을 허용 목록에 추가한다.\n\n```ts\nexport const SANITIZE_OPTIONS = {\n  ADD_ATTR: [\n    // 기존 속성들...\n    \"sandbox\",   // iframe 보안 정책\n    \"srcdoc\",    // iframe 인라인 콘텐츠\n    \"onclick\",   // 토글 버튼용\n  ],\n  ADD_TAGS: [\n    // 기존 태그들...\n    \"iframe\",    // 프리뷰 컨테이너\n    \"button\",    // 코드 보기 토글\n  ],\n}\n```\n\n### 4. CSS 스타일링\n\n`src/styles/markdown.css`에서 프리뷰 컨테이너 스타일을 정의한다.\n\n```css\n/* 컨테이너 */\n.html-preview-container {\n  margin: 20px 0;\n  border: 1px solid var(--border);\n  border-radius: 8px;\n  overflow: hidden;\n}\n\n/* 헤더 (라벨 + 토글 버튼) */\n.html-preview-header {\n  display: flex;\n  justify-content: space-between;\n  padding: 8px 12px;\n  background-color: var(--muted);\n}\n\n/* iframe */\n.html-preview-frame {\n  width: 100%;\n  min-height: 150px;\n  border: none;\n  background: white;\n}\n\n/* 소스 코드 (기본 숨김) */\n.html-preview-source {\n  display: none;\n}\n\n/* 토글 시 소스 코드 표시 */\n.html-preview-container.show-code .html-preview-source {\n  display: block;\n}\n```\n\n### 5. sandbox 속성 상세\n\niframe의 `sandbox` 속성은 보안 정책을 세밀하게 제어한다.\n\n| 값 | 허용 | 차단 |\n|----|------|------|\n| `allow-scripts` | JavaScript 실행 | - |\n| (미지정) | - | 부모 DOM 접근 |\n| (미지정) | - | 쿠키/스토리지 |\n| (미지정) | - | 폼 제출 |\n| (미지정) | - | 팝업/모달 |\n\n`allow-same-origin`을 추가하면 부모 페이지 접근이 가능해지므로 **절대 추가하지 않는다**.\n\n### 파일 구조\n\n```\nsrc/utils/markdown/\n├── index.ts          # renderMarkdown 진입점\n├── renderer.ts       # 커스텀 렌더러 (html-preview 처리)\n├── constants.ts      # DOMPurify 설정\n├── helpers.ts        # escapeHtml 등 유틸\n└── extensions/       # 콜아웃, 위키링크 등\n\nsrc/styles/\n└── markdown.css      # html-preview 스타일\n```",
      "dateCreated": "2025-01-19",
      "dateUpdated": "2025-01-19"
    },
    {
      "id": "base-router-설정",
      "title": "base router 설정",
      "tags": [
        "BUGFIX",
        "react",
        "tanstack-router"
      ],
      "content": "<br/>\n\n> [!NOTE]+ 환경\n>\n> \\- React 19\n> \\- Vite\n> \\- Tanstack Router\n> \\- Vercel\n\n<br/>\n\nSPA 환경에서 TanStack Router를 사용하여 애플리케이션을 개발하던 중, 브라우저 주소창에 /myapp/xxx 와 같은 서브 경로를 직접 입력하면 404 오류가 발생하는 것을 확인하였습니다. 그러나 라우터 링크를 통해 내부 페이지로 이동하는 것은 정상적으로 동작하였습니다. 네트워크 요청을 확인해본 결과, 브라우저가 해당 경로에 실제 정적 파일이 존재하는지 확인하다가 찾지 못해 404를 반환하고 있음을 알게 되었습니다.\n\n<br/>\n\n공식 문서(TanStack Router Docs, Vercel Rewrites)를 참고한 결과, SPA는 최초에 index.html을 로드한 뒤 클라이언트 라우터가 동작하기 때문에, 서버(또는 호스팅 플랫폼)에서 존재하지 않는 경로로의 요청을 index.html로 리라이트해야 함을 알게 되었습니다. 또한 애플리케이션을 루트가 아닌 /myapp 경로에 배포했기 때문에, 라우터 basepath와 빌드 경로 설정도 일관되게 맞추어야 함을 확인하였습니다.\n\n<br/><br/>\n\n이를 해결하기 위해 다음과 같이 수정하였습니다.\n\n<br/>\n\n1. TanStack Router basepath 지정\n\n```ts\nimport { createRouter } from '@tanstack/react-router'\n\nconst router = createRouter({\n  routeTree,\n  basepath: '/myapp',\n})\n```\n\n→ 라우터가 /myapp을 기준으로 경로를 인식하도록 수정하였습니다.\n\n<br/>\n\n2. Vite 설정 수정\n\n```ts\n// vite.config.ts\nexport default defineConfig({\n  base: '/myapp/',\n})\n```\n\n→ 빌드된 정적 자산(js, css 등)이 올바른 경로에서 로드되도록 하였습니다.\n\n<br/>\n\n3. Vercel 리라이트 설정 추가\n\n```json\n// vercel.json\n{\n  \"rewrites\": [\n    {\n      \"source\": \"/myapp/(.*)\",\n      \"destination\": \"/myapp/index.html\"\n    }\n  ]\n}\n```\n\n→ /myapp 이하의 모든 경로를 index.html로 전달하도록 하였습니다.\n\n<br/><br/>\n\n이 과정을 거친 후 브라우저 주소창에 /myapp/xxx 와 같은 경로를 직접 입력해도 Vercel이 index.html을 반환하게 되었고, TanStack Router가 정상적으로 초기화되어 해당 경로를 매칭할 수 있었습니다. 결과적으로 내부 링크 이동과 직접 주소 입력이 동일하게 동작하는 일관된 라우팅 경험을 제공할 수 있었습니다.\n\n<br/>\n\n이번 경험을 통해 CSR 기반 라우팅에서는 배포 환경에 맞는 index.html fallback 설정이 필수적임을 학습하였습니다. 특히 Vercel과 같은 정적 호스팅 환경에서는 vercel.json의 rewrite 규칙을 통해 라우팅 문제를 해결할 수 있음을 확인하였습니다. 또한 애플리케이션을 서브 경로에 배포할 경우 라우터 basepath, 빌드 base 설정, 호스팅 플랫폼의 리라이트 규칙을 반드시 일관되게 구성해야 함을 깨달았습니다.",
      "dateCreated": "2025-09-04"
    },
    {
      "id": "cv",
      "title": "CV",
      "tags": [
        "about-me"
      ],
      "content": "김혜경 입니다.\n</br>\n아주대학교에서 미디어학과 소프트웨어공학을 전공하고, 동대학원에서 이경원 교수님 지도하에 데이터시각화에 대해 연구하고 있습니다.\n24년 9월부터 NSHC MSSP팀에 소속되어\n\n- 팀원이 보다 편하게 업무를 수행할 수 있도록 돕는 소프트웨어 어플리케이션을 개발하고\n- 민감 유출 데이터에 대한 분석 및 시각화를 연구하고 있습니다.\n\n---\n\n- 2024년 9월 ~ : NSHC MSSP팀\n- 2024년 3월: 아주대학교 디지털미디어학 석사과정 입학 (지도교수: 이경원 교수님)\n- 2024년 2월: 아주대학교 졸업 (미디어학, 소프트웨어공학)\n- 2022~2023년 : 아주대학교 미디어학과 IDLAbs 학부 연구생",
      "dateCreated": "2026-01-19",
      "dateUpdated": "2026-01-19"
    },
    {
      "id": "flex",
      "title": "flex",
      "tags": [
        "css"
      ],
      "content": "> Flexbox(CSS Flexible Box Layout Module) 에서 아이템 단위에 적용되는 단축 속성\n\n<br/>\n\nFlexbox는 레이아웃 전체 시스템을 의미하며, 컨테이너와 그 안의 아이템들이 공간을 배치·정렬·분배하는 방식에 대한 큰 틀의 규칙과 개념이다.\n\n- 컨테이너 속성\n  - display: flex\n  - flex-direction\n  - justify-content\n  - aling-items\n  - flex-wrap 등\n- 아이템 속성\n  - _flex-grow_\n  - _flex-shrink_\n  - _flex-basis_\n  - align-self\n  - order 등\n\n<br/>\n\n여기서 아이템용 속성 중 flex는 **아이템의 크기를 어떻게 분배하고, 공간이 부족하거나 남을 때 어떻게 행동할지 결정하는 것**으로, 단축 속성으로도 작성할 수 있다.\n\n```css\nflex: <flex-grow> <flex-shrink> <flex-basis>;\n```\n\n<br/>\n\n1. **flex-grow**\n   - 컨테이너 안에 남는 공간이 있으면, 각 아이템의 flex-grow 값에 따라 분배된다.\n   - 기본값: 0 (남는 공간을 차지하지 않음)\n     - 1: 동일한 비율로 남는 공간 분배\n     - n: 값이 1인 요소보다 n 배 더 많이 차지\n\n   ```css\n   .item1 {\n     flex-grow: 1;\n   }\n   .item2 {\n     flex-grow: 2;\n   }\n   ```\n\n   컨테이너 여유 공간이 300px 라면, item1은 100px, item2는 200px 를 추가로 갖는다.\n\n<br/>\n\n2. **flex-shrink**\n\n- 컨테이너가 좁아지면 각 아이템이 flex-shrink 값 비율만큼 줄어든다.\n- 기본값: 1 (줄어든다)\n  - 0: 줄어들지 않는다.\n  - n: 1인 다른 요소보다 n배 더 빨리 줄어든다.\n\n  ```css\n  .item1 {\n    flex-shrink: 1;\n  }\n  .item2 {\n    flex-shrink: 0;\n  }\n  ```\n\n  컨테이너 공간이 부족해지면 item1은 줄어들고, item2는 줄어들지 않는다.\n\n<br/>\n\n3. **flex-basis**\n\n- grow/shrink 연산이 적용되기 전에 아이템의 기준 크기를 설정한다.\n- 기본값: auto (아이템에 정의된 width, height를 따른다)\n  - n px, %: 이 지정 크기에서 출발한다. 이후 grow, shrink 규칙이 적용된다.\n\n```css\n.item {\n  flex-basis: 150px;\n  flex-grow: 1;\n}\n```\n\n기본 크기는 150px, 컨테이너에 여유 공간이 있으면 추가로 확장된다.",
      "dateCreated": "2025-09-11",
      "dateUpdated": "2025-09-15"
    },
    {
      "id": "god-object",
      "title": "God Object",
      "tags": [
        "pattern",
        "anti",
        "code-smell"
      ],
      "content": "[[단일 책임 원칙(SRP)]]에 반하는 안티패턴으로, 특정 클래스나 객체가 과도하게 많은 책임과 기능을 떠맡아, 마치 모든 것을 통제하는 신처럼 시스템 전반에 관여하는 상황을 가리킨다.\n\n이 경우, 한 객체에 지나치게 많은 데이터와 로직이 몰려 있어, 프로젝트가 커질수록 이 객체는 점점 비대해지고, 수정이나 확장 시 다른 부분까지 연쇄적으로 영향을 미친다. 이는 코드 이해도를 저하시킬 뿐만 아니라, 팀 생산성을 저해하며, 버그 발생 가능성을 높이는 구조적 문제를 야기한다. 또한 복잡한 의존성으로 인해 단위 테스트 및 재사용도 어려워진다.\n\n<br/>\n\n이런 상황을 피하기 위해선 다음과 같은 접근이 필요하다:\n\n- **단일 책임 원칙을 준수**하여, 클래스마다 한 가지 역할만을 담당하도록 하고\n- 데이터 접근, 비즈니스 로직, 프레젠테이션 레이어 분리를 통해 **레이어드 아키텍처를 적용**한다.\n- 혹은 전략 패턴, 옵저버 패턴, 리포지토리 **패턴 등을 적용**해 역할을 분산시킨다.\n\n<br/>\n\n---\n\n<br/>\n\n### 참고\n\n- [Yak Shaving: 야크 털 깎기:티스토리](https://nodiscard.tistory.com/381)",
      "dateCreated": "2025-09-15",
      "dateUpdated": "2025-09-15"
    },
    {
      "id": "react-memo",
      "title": "React.memo",
      "tags": [
        "react",
        "불변성"
      ],
      "content": "React.memo는 React에서 함수형 컴포넌트의 불필요한 리렌더링을 방지하기 위한 고차 컴포넌트(HOC)이다.\n\nReact.memo는 얕은 비교(shallow comparison) 를 통해 이전 props와 새 props가 동일하면 리렌더링을 건너뛴다.\n\n즉, 동일한 props가 들어오면 컴포넌트를 **다시 렌더링하지 않고 이전에 렌더링된 결과를 재사용**한다.\n\n다만,\n\n- 얕은 비교 한계: React.memo는 props 객체를 얕게 비교하기 때문에, 객체나 배열 같은 참조 타입이 매번 새로 만들어지면 매번 다르다고 판단한다. 이 경우 [[useMemo|useMemo]]나 [[useCallback]]으로 안정된 참조를 제공해야 한다.\n- 모든 경우에 성능 향상 X: React.memo 자체도 비교 연산 비용이 있기 때문에, 단순한 컴포넌트에는 오히려 성능 이득이 없다. 렌더링 비용이 큰 컴포넌트에 적용하는 것이 적절하다.",
      "dateCreated": "2025-09-10"
    },
    {
      "id": "web-browser-engineering",
      "title": "웹 브라우저 엔지니어링",
      "tags": [
        "web",
        "web-rendering"
      ],
      "content": "> [웹 브라우저 엔지니어링](https://browser.engineering/intro.html) 을 읽으며 정리한 문서 모음\n\n<br/>\n\n## INTRO\n\n- [[선언적-웹-아키텍처|선언적 웹 아키텍처]]\n\n<br/>\n\n## PART 1: Loading Pages\n\n- [[웹-페이지-다운로드|웹 페이지 다운로드]]",
      "dateCreated": "2025-09-11",
      "dateUpdated": "2025-09-11"
    },
    {
      "id": "마크다운-문법",
      "title": "마크다운 문법",
      "tags": [
        "note-vis",
        "markdown"
      ],
      "content": "# header1\n\n## header2\n\n### header3\n\n<br/>\n\n- 테스트1\n  - 테스트2\n\n<br/>\n\n**볼드**\n_이텔릭_\n---취소선---\n`코드`\n\n<br/>\n\n> [!NOTE] -\n>\n> 콜아웃\n> !NOTE, !INFO\n\n<br/>\n\n```\n코드 블럭\nconst test = \"hello world!\"\n```\n\n<br/>\n\n각주[^1]\n\n<br/>\n\n| 표   | 설명 |\n| ---- | ---- |\n| 내용 | 내용 |\n\n[^1]: 각주 입니다.",
      "dateCreated": "2025-09-11",
      "dateUpdated": "2026-01-19"
    },
    {
      "id": "마크다운-파싱-시스템",
      "title": "마크다운 파싱 시스템",
      "tags": [
        "note-vis",
        "markdown",
        "parsing"
      ],
      "content": "이 프로젝트의 마크다운 파싱 시스템은 **빌드 타임**과 **런타임** 두 단계로 구성된다.\n\n## 1. 빌드 타임 파싱\n\n`scripts/parse-notes.js`가 `notes/` 폴더의 마크다운 파일들을 파싱하여 그래프 데이터를 생성한다.\n\n### 실행 시점\n\n- `npm run build` 실행 시 자동으로 실행\n- `npm run parse-notes`로 수동 실행 가능\n\n### 파싱 과정\n\n```\nnotes/*.md → parse-notes.js → src/data/notes.json\n```\n\n### Frontmatter 파싱\n\n각 마크다운 파일 상단의 YAML frontmatter에서 메타데이터를 추출한다.\n\n| 필드    | 정규식                                                    | 설명      |\n| ------- | --------------------------------------------------------- | --------- |\n| title   | `title:\\s*[\"']?([^\"'\\n]+)[\"']?`                           | 노트 제목 |\n| tags    | `tags:\\s*\\[(.*?)\\]`                                       | 태그 배열 |\n| related | `related:\\s*\\[(.*?)\\]`                                    | 관련 노트 |\n| created | `created(?:\\s+date)?:\\s*[\"']?([^\"'\\n]+)[\"']?`             | 생성일    |\n| updated | `(?:updated\\|edited)(?:\\s+date)?:\\s*[\"']?([^\"'\\n]+)[\"']?` | 수정일    |\n\n### Wiki Link 추출\n\n본문에서 `[[링크]]` 패턴을 찾아 노트 간 연결 관계를 추출한다.\n\n```javascript\nconst REGEX = {\n  wikiLink: /\\[\\[([^\\]]+)\\]\\]/g,\n};\n```\n\n파이프 링크 `[[target|display]]`도 지원하며, target 부분만 링크 대상으로 사용한다.\n\n### 출력 데이터 구조\n\n```json\n{\n  \"nodes\": [\n    {\n      \"id\": \"파일명\",\n      \"title\": \"노트 제목\",\n      \"tags\": [\"태그1\", \"태그2\"],\n      \"content\": \"frontmatter 제외한 본문\",\n      \"dateCreated\": \"2025-01-01\",\n      \"dateUpdated\": \"2025-01-15\"\n    },\n    {\n      \"id\": \"tag:태그명\",\n      \"title\": \"#태그명\"\n    }\n  ],\n  \"links\": [\n    { \"source\": \"노트A\", \"target\": \"노트B\", \"type\": \"mention\" },\n    { \"source\": \"노트A\", \"target\": \"tag:태그\", \"type\": \"tag\" }\n  ]\n}\n```\n\n### 깨진 링크 처리\n\n존재하지 않는 노트를 참조하는 링크는 `broken: true` 플래그가 추가된다.\n\n---\n\n## 2. 런타임 렌더링\n\n`src/utils/markdown/` 모듈이 노트 상세 페이지에서 마크다운을 HTML로 렌더링한다. 사용자가 노트를 클릭하면 저장된 마크다운 본문(`content`)이 이 모듈을 통해 실시간으로 HTML로 변환된다.\n\n### 모듈 구조\n\n```\nsrc/utils/markdown/\n├── index.ts          # renderMarkdown() 메인 함수\n├── extensions/\n│   ├── index.ts      # extension export\n│   ├── wikilink.ts   # [[wiki link]] 커스텀 토크나이저/렌더러\n│   └── callout.ts    # > [!NOTE] 콜아웃 처리\n├── renderer.ts       # 코드 하이라이팅, 링크 정책\n├── helpers.ts        # 유틸리티 함수\n├── constants.ts      # 설정값\n└── types.ts          # TypeScript 타입 정의\n```\n\n### 메인 함수: renderMarkdown()\n\n`index.ts`의 `renderMarkdown()` 함수가 전체 렌더링 파이프라인을 관리한다.\n\n```typescript\nexport function renderMarkdown(\n  markdown: string,\n  brokenLinks?: Set<string>,\n): RenderResult {\n  // 1. 깨진 링크 컨텍스트 설정\n  setBrokenLinks(brokenLinks || new Set());\n\n  // 2. 각주 추출 및 처리\n  const footnotes = extractFootnotes(markdown);\n  let contentWithoutFootnoteDefs = removeFootnoteDefinitions(markdown);\n  if (footnotes.length > 0) {\n    contentWithoutFootnoteDefs = replaceFootnoteReferences(\n      contentWithoutFootnoteDefs,\n    );\n  }\n\n  // 3. marked로 HTML 변환\n  const html = marked.parse(contentWithoutFootnoteDefs) as string;\n  const footnotesHtml = renderFootnotesHtml(footnotes);\n\n  // 4. 프로덕션에서 DOMPurify 적용\n  if (import.meta.env.DEV) {\n    return { content: html, footnotes: footnotesHtml };\n  }\n  return {\n    content: DOMPurify.sanitize(html, SANITIZE_OPTIONS),\n    footnotes: DOMPurify.sanitize(footnotesHtml, SANITIZE_OPTIONS),\n  };\n}\n```\n\n### marked 라이브러리 확장\n\n[marked](https://marked.js.org/)는 마크다운을 HTML로 변환하는 라이브러리다. 이 프로젝트에서는 커스텀 extension을 통해 Obsidian 스타일 문법을 지원한다.\n\n**초기화 (setupMarked)**:\n\n```typescript\nfunction setupMarked(): void {\n  const renderer = createRendererWithLinkPolicy();\n  marked.use({ renderer });\n  marked.use({\n    extensions: [\n      wikiLinkTokenizer, // [[link]] 토큰화\n      wikiLinkRenderer, // [[link]] HTML 변환\n      calloutTokenizer, // > [!NOTE] 토큰화\n      calloutRenderer, // > [!NOTE] HTML 변환\n    ],\n  });\n  marked.setOptions({\n    gfm: true, // GitHub Flavored Markdown\n    breaks: true, // 줄바꿈을 <br>로 변환\n  });\n}\n\nsetupMarked(); // 모듈 로드 시 한 번 실행\n```\n\n---\n\n### Wiki Link Extension 상세\n\nObsidian의 `[[wiki link]]` 문법을 지원한다.\n\n#### Tokenizer (토큰화)\n\n마크다운 파싱 단계에서 `[[...]]` 패턴을 찾아 커스텀 토큰으로 변환한다.\n\n```typescript\nexport const wikiLinkTokenizer: TokenizerExtension = {\n  name: \"wikilink\",\n  level: \"inline\", // 인라인 요소로 처리\n\n  // 패턴 시작 위치 탐색 (성능 최적화)\n  start(src: string) {\n    const i = src.indexOf(\"[[\");\n    return i === -1 ? undefined : i;\n  },\n\n  // 실제 토큰화\n  tokenizer(src): WikiLinkToken | undefined {\n    // [[target]] 또는 [[target|별칭]] 패턴 매칭\n    const match = /^\\[\\[([^\\]|]+?)(?:\\|([^\\]]+?))?\\]\\]/.exec(src);\n    if (!match) return undefined;\n\n    const [, rawName, alias] = match;\n    const text = alias ? alias.trim() : rawName.trim();\n    const href = `/node/${slugifyNode(rawName)}`;\n\n    return {\n      type: \"wikilink\",\n      raw: match[0], // 원본 문자열 (marked가 소비)\n      href,\n      text,\n    };\n  },\n};\n```\n\n**예시**:\n\n- `[[React.memo]]` → `{ href: '/node/React.memo', text: 'React.memo' }`\n- `[[React.memo|메모]]` → `{ href: '/node/React.memo', text: '메모' }`\n\n#### Renderer (HTML 변환)\n\n토큰을 HTML `<a>` 태그로 변환한다.\n\n```typescript\nexport const wikiLinkRenderer: RendererExtension = {\n  name: \"wikilink\",\n  renderer(token: Tokens.Generic) {\n    const wikiToken = token as WikiLinkToken;\n    const brokenLinks = getBrokenLinks();\n\n    // URL에서 노트 ID 추출\n    const targetId = wikiToken.href.replace(\"/node/\", \"\").replace(/%20/g, \" \");\n    const isBroken = brokenLinks.has(decodeURIComponent(targetId));\n\n    // 깨진 링크는 class 추가 + href를 #으로\n    const className = isBroken ? ' class=\"broken-link\"' : \"\";\n    const href = isBroken ? \"#\" : wikiToken.href;\n\n    return `<a href=\"${href}\"${className}>${escapeHtml(wikiToken.text)}</a>`;\n  },\n};\n```\n\n**깨진 링크 처리**:\n\n- 존재하지 않는 노트를 참조하면 `class=\"broken-link\"` 추가\n- CSS로 취소선, 빨간색 등 스타일링 가능\n\n---\n\n### Callout Extension 상세\n\nObsidian 스타일의 콜아웃(인용 블록 확장) 문법을 지원한다.\n\n#### 문법\n\n```markdown\n> [!NOTE] 커스텀 제목\n> 콜아웃 내용\n> 여러 줄 가능\n```\n\n#### Tokenizer\n\n```typescript\nexport const calloutTokenizer: TokenizerExtension = {\n  name: \"callout\",\n  level: \"block\", // 블록 요소로 처리\n\n  start(src: string) {\n    const i = src.indexOf(\"> [!\");\n    return i === -1 ? undefined : i;\n  },\n\n  tokenizer(src): CalloutToken | undefined {\n    // 인용 블록 전체 매칭\n    const cap = /^(?:> ?(.*)\\n?)+/.exec(src);\n    if (!cap) return undefined;\n\n    // 각 줄에서 '> ' 제거\n    const lines = cap[0]\n      .trimEnd()\n      .split(\"\\n\")\n      .map((l) => l.replace(/^>\\s?/, \"\"));\n\n    // 첫 줄에서 [!TYPE] 패턴 확인\n    const head = lines[0];\n    const headMatch = /^\\[!(NOTE|INFO)\\]([+-])?(?:\\s+(.*))?$/i.exec(head);\n    if (!headMatch) return undefined;\n\n    const [, typeRaw, collapseFlag, customTitle] = headMatch;\n    const calloutType = typeRaw.toUpperCase() as CalloutKind;\n\n    // 접기 상태: '-'면 접힘, '+'면 펼침, 없으면 undefined\n    const collapsed =\n      collapseFlag === \"-\" ? true : collapseFlag === \"+\" ? false : undefined;\n\n    // 본문 (첫 줄 제외)을 재귀적으로 파싱\n    const body = lines.slice(1).join(\"\\n\");\n    const bodyTokens = this.lexer.blockTokens(body, []);\n\n    return {\n      type: \"callout\",\n      raw: cap[0],\n      calloutType,\n      title: customTitle?.trim(),\n      collapsed,\n      tokens: bodyTokens,\n    };\n  },\n};\n```\n\n#### Renderer\n\n```typescript\nexport const calloutRenderer: RendererExtension = {\n  name: \"callout\",\n  renderer(token: Tokens.Generic) {\n    const calloutToken = token as CalloutToken;\n    const cfg = CALLOUTS[calloutToken.calloutType]; // 설정 조회\n    const title = calloutToken.title || cfg.defaultTitle;\n\n    // 접기 상태에 따라 open 속성 결정\n    const detailsOpen =\n      calloutToken.collapsed === undefined\n        ? \" open\"\n        : calloutToken.collapsed\n          ? \"\"\n          : \" open\";\n\n    // 본문 토큰을 재귀적으로 렌더링\n    const inner = this.parser.parse(calloutToken.tokens);\n\n    return `\n<aside class=\"callout ${cfg.className}\" role=\"note\" aria-label=\"${cfg.ariaLabel}\">\n  <details class=\"callout-details\"${detailsOpen}>\n    <summary class=\"callout-header\">\n      <span class=\"callout-title\">${title}</span>\n    </summary>\n    <div class=\"callout-content\">\n${inner}\n    </div>\n  </details>\n</aside>`.trim();\n  },\n};\n```\n\n**Callout 설정** (`constants.ts`):\n\n```typescript\nexport const CALLOUTS: Record<CalloutKind, CalloutConfig> = {\n  NOTE: {\n    className: \"callout-note\",\n    defaultTitle: \"노트\",\n    ariaLabel: \"Note\",\n  },\n  INFO: {\n    className: \"callout-info\",\n    defaultTitle: \"정보\",\n    ariaLabel: \"Info\",\n  },\n};\n```\n\n---\n\n### 각주(Footnotes) 처리 상세\n\n마크다운 각주를 클릭 가능한 링크로 변환한다.\n\n#### 처리 단계\n\n**1. 각주 정의 추출**:\n\n```typescript\nfunction extractFootnotes(markdown: string): Array<Footnote> {\n  const footnotes: Array<Footnote> = [];\n  // 각주 정의 패턴: [^label]: content\n  const footnoteMatches = markdown.match(/^\\[\\^([^\\]]+)\\]:\\s*(.*)$/gm);\n\n  if (footnoteMatches) {\n    footnoteMatches.forEach((matchStr) => {\n      const parts = matchStr.match(/^\\[\\^([^\\]]+)\\]:\\s*(.*)$/);\n      if (parts) {\n        footnotes.push({\n          label: parts[1].trim(),\n          content: parts[2].trim(),\n        });\n      }\n    });\n  }\n  return footnotes;\n}\n```\n\n**2. 본문에서 각주 정의 제거**:\n\n```typescript\nfunction removeFootnoteDefinitions(markdown: string): string {\n  return markdown.replace(/^\\[\\^([^\\]]+)\\]:\\s*.*$/gm, \"\").trim();\n}\n```\n\n**3. 참조를 링크로 변환**:\n\n```typescript\nfunction replaceFootnoteReferences(content: string): string {\n  return content.replace(\n    /\\[\\^([^\\]]+)\\]/g,\n    '<sup class=\"footnote-ref\"><a href=\"#footnote-$1\" id=\"footnote-ref-$1\" class=\"footnote-link\">$1</a></sup>',\n  );\n}\n```\n\n**4. 각주 목록 HTML 생성**:\n\n```typescript\nfunction renderFootnotesHtml(footnotes: Array<Footnote>): string {\n  if (footnotes.length === 0) return \"\";\n\n  return footnotes\n    .map(\n      (fn) =>\n        `<div class=\"footnote-def\" id=\"footnote-${fn.label}\">\n      <a href=\"#footnote-ref-${fn.label}\" class=\"footnote-backref\">${fn.label}</a>: ${marked.parseInline(fn.content)}\n    </div>`,\n    )\n    .join(\"\");\n}\n```\n\n**결과**:\n\n- 본문의 `[^1]` → `<sup><a href=\"#footnote-1\">1</a></sup>`\n- 페이지 하단에 각주 목록 표시\n- 양방향 링크로 이동 가능\n\n---\n\n### 코드 하이라이팅 상세\n\n`renderer.ts`에서 코드 블록에 간단한 구문 하이라이팅을 적용한다.\n\n#### JavaScript/TypeScript 하이라이팅\n\n```typescript\nfunction highlightJavaScript(code: string): string {\n  let highlighted = escapeHtml(formatCode(code));\n  const placeholders = new Map<string, string>();\n  let placeholderIndex = 0;\n\n  // 1. 문자열 먼저 처리 (키워드 오탐 방지)\n  highlighted = highlighted.replace(/([\"'`])([^\"'`]*?)\\1/g, (match) => {\n    const placeholder = `__STRING_${placeholderIndex++}__`;\n    placeholders.set(placeholder, `<span class=\"token string\">${match}</span>`);\n    return placeholder;\n  });\n\n  // 2. 주석 처리\n  highlighted = highlighted.replace(/\\/\\/.*$/gm, (match) => {\n    const placeholder = `__COMMENT_${placeholderIndex++}__`;\n    placeholders.set(\n      placeholder,\n      `<span class=\"token comment\">${match}</span>`,\n    );\n    return placeholder;\n  });\n\n  // 3. 키워드 처리\n  highlighted = highlighted.replace(\n    /\\b(const|let|var|function|import|export|from|default|createRouter|defineConfig)\\b/g,\n    '<span class=\"token keyword\">$1</span>',\n  );\n\n  // 4. 숫자 처리\n  highlighted = highlighted.replace(\n    /\\b(\\d+)\\b/g,\n    '<span class=\"token number\">$1</span>',\n  );\n\n  // 5. placeholder 복원\n  placeholders.forEach((replacement, placeholder) => {\n    highlighted = highlighted.replace(placeholder, replacement);\n  });\n\n  return highlighted;\n}\n```\n\n**placeholder 패턴의 이유**: 문자열 안의 키워드(`\"const\"`)가 하이라이팅되지 않도록 문자열을 먼저 치환 후 복원한다.\n\n#### 코드 렌더러\n\n```typescript\ncode({ text: code, lang }: { text: string; lang?: string }) {\n  let highlighted: string;\n\n  const jsLangs = ['ts', 'js', 'javascript', 'typescript', 'jsx', 'tsx'];\n\n  if (isJavaScriptLike(code) || (lang && jsLangs.includes(lang))) {\n    highlighted = highlightJavaScript(code);\n  } else if (isJSONLike(code) || lang === 'json') {\n    highlighted = highlightJSON(code);\n  } else {\n    highlighted = escapeHtml(formatCode(code));\n  }\n\n  return `<pre><code class=\"${lang ? `language-${lang}` : ''}\">${highlighted}</code></pre>`;\n}\n```\n\n---\n\n### 링크 정책\n\n외부 링크와 내부 링크를 다르게 처리한다.\n\n```typescript\nlink({ href, title, text }: { href: string; title?: string | null; text: string }): string {\n  const cleanTitle = title ? ` title=\"${title}\"` : '';\n  if (!href) return `<a${cleanTitle}>${text}</a>`;\n\n  const isExternal = /^https?:\\/\\//i.test(href);\n  const target = isExternal ? ' target=\"_blank\" rel=\"noopener noreferrer\"' : '';\n\n  return `<a href=\"${href}\"${cleanTitle}${target}>${text}</a>`;\n}\n```\n\n- **외부 링크** (`https://...`): 새 탭에서 열림 + `noopener noreferrer`로 보안 강화\n- **내부 링크**: 같은 탭에서 열림\n\n---\n\n### 보안: DOMPurify 상세\n\n프로덕션 환경에서는 XSS 공격 방지를 위해 DOMPurify로 HTML을 정화한다.\n\n```typescript\nexport const SANITIZE_OPTIONS = {\n  ADD_ATTR: [\"target\", \"rel\", \"open\", \"class\", \"href\", \"id\"],\n  ADD_TAGS: [\"span\", \"sup\", \"a\"],\n  ALLOWED_URI_REGEXP:\n    /^(?:(?:https?|mailto|tel|data:image\\/(?:png|gif|jpeg|webp));|\\/|#)/i,\n};\n```\n\n| 옵션                 | 설명                               |\n| -------------------- | ---------------------------------- |\n| `ADD_ATTR`           | 허용할 HTML 속성                   |\n| `ADD_TAGS`           | 허용할 HTML 태그                   |\n| `ALLOWED_URI_REGEXP` | 허용할 URI 패턴 (javascript: 차단) |\n\n**개발 환경에서 비활성화하는 이유**:\n\n- 빠른 렌더링 (DOMPurify 오버헤드 제거)\n- 개발 중 XSS 테스트 가능\n\n---\n\n### 표(Table) 렌더링\n\nGFM(GitHub Flavored Markdown) 표 문법을 지원한다. marked의 `gfm: true` 옵션으로 기본 지원되며, CSS로 스타일링한다.\n\n#### 문법\n\n```markdown\n| 필드  | 설명      |\n| ----- | --------- |\n| title | 노트 제목 |\n| tags  | 태그 배열 |\n```\n\n#### 정렬 지원\n\n```markdown\n| 왼쪽 | 가운데 | 오른쪽 |\n| :--- | :----: | -----: |\n| L    |   C    |      R |\n```\n\n- `:---` : 왼쪽 정렬\n- `:---:` : 가운데 정렬\n- `---:` : 오른쪽 정렬\n\n#### 스타일링 (CSS)\n\n```css\n.markdown-content table {\n  width: 100%;\n  border-collapse: collapse;\n  font-size: 14px;\n  margin: 16px 0;\n  border: 1px solid var(--border);\n  border-radius: 8px;\n  overflow: hidden;\n}\n\n.markdown-content table thead {\n  background-color: var(--muted);\n}\n\n.markdown-content table th {\n  padding: 10px 14px;\n  font-weight: 600;\n  border-bottom: 2px solid var(--border);\n}\n\n.markdown-content table td {\n  padding: 10px 14px;\n  border-bottom: 1px solid var(--border);\n}\n\n.markdown-content table tbody tr:hover {\n  background-color: color-mix(in oklab, var(--muted) 50%, transparent);\n}\n```\n\n**설계 결정**: marked의 table 렌더러 API가 토큰 객체를 전달하므로, 커스텀 렌더러 대신 기본 렌더러를 사용하고 CSS로 스타일링한다.\n\n---\n\n### 구분선(Horizontal Rule) 렌더링\n\n마크다운 구분선을 커스텀 스타일로 렌더링한다.\n\n#### 문법\n\n```markdown\n---\n```\n\n또는 `***`, `___`도 가능하다.\n\n#### 커스텀 렌더러\n\n```typescript\nhr(): string {\n  return '<hr class=\"markdown-hr\" />'\n}\n```\n\n#### 스타일링 (CSS)\n\n```css\n.markdown-content .markdown-hr {\n  border: 0.5px solid var(--border);\n  margin: 72px 0;\n}\n```\n\n넓은 여백(72px)으로 섹션 구분을 명확하게 한다.\n\n---\n\n## 데이터 흐름 요약\n\n```\n[빌드 타임]\nnotes/*.md\n    ↓ parse-notes.js\nsrc/data/notes.json (그래프 데이터)\n    ↓\nNetworkGraph 컴포넌트 (시각화)\n\n[런타임]\n노트 클릭\n    ↓\nNodeContent 컴포넌트\n    ↓ renderMarkdown()\nHTML 렌더링 (wiki link, callout, footnotes 처리)\n```",
      "dateCreated": "2026-01-19",
      "dateUpdated": "2026-01-19"
    },
    {
      "id": "배열-튜플-딕셔너리",
      "title": "배열, 튜플, 딕셔너리",
      "tags": [
        "python"
      ],
      "content": "**배열**\n\n- arr=[]\n- arr=[1, 2, 3, 4]\n- arr[0]\n\n<br/>\n\n**튜플**\n\n- tup=()\n- tup=(1,2,3,4)\n- tup=[0]\n- 생성 후 값 삭제, 변경 불가\n\n<br/>\n\n**딕셔너리**\n\n- dic={}\n- dic{\"a\":1, \"b\":2, \"c\":3}\n- dic[\"1\"]\n- key값 사용하여 값 접근\n- 중복 key 불가",
      "dateCreated": "2025-09-23",
      "dateUpdated": "2025-09-23"
    },
    {
      "id": "선언적-웹-아키텍처",
      "title": "선언적 웹 아키텍쳐",
      "tags": [
        "web",
        "페러다임"
      ],
      "content": "> 출처: [웹 브라우저 엔지니어링](https://browser.engineering/intro.html)\n\n<br/>\n\n- 웹은 하이퍼링크로 연결된 정보의 네트워크이다.\n- 사용자는 브라우저 라고 하는 사용자 에이전트를 사용하여 웹을 탐색한다.\n- 정보는 HTTP(HyperText Transfer Protocol)를 통해 요청되고 HTML 문서 형식으로 구조화됩니다 .\n- 문서는 내용이 아닌 URL(Uniform Resource Locator)로 식별되며 동적으로 생성될 있다.\n- 웹 페이지는 이미지, 비디오, CSS(Cascading Style Sheets), JavaScript를 포함한 다양한 형식의 보조 자산에 링크할 수 있다.\n- 이러한 모든 구성 요소는 개방적이고 표준화되어 있으며 무료로 사용하거나 재사용할 수 있다.\n\n<br/>\n\n웹 브라우저의 동작을 가능하게 하는 핵심은 **제어의 역전(inversion of control)**, **제약 프로그래밍(constraint programming)**, 그리고 **선언적 프로그래밍(declarative programming)** 의 구현에 있다.\n\n> [!NOTE] -\n> **제어의 역전**\n>\n> 일반적으로 전통적 프로그래밍은 개발자가 “순서대로” 동작을 직접 제어하지만, 하지만 웹에서는 브라우저가 중심이 되어 렌더링, 이벤트 처리, 동기화 등을 맡고, 개발자는 선언적으로 지시만 한다. 웹 브라우저는 거대한 프레임워크라고 볼 수 있다.\n> \\\n> **제약 프로그래밍**\n>\n> 웹 레이아웃은 절대 좌표 기반이 아니라, “이 요소는 저 요소 옆에 있어야 한다”, “이 너비는 부모의 50%여야 한다” 같은 제약식으로 표현된다. (flexbox, grid)\n> \\\n> **선언적 프로그래밍**\n>\n> 개발자는 무엇을 원한다만 기술한다. 어떻게 실행되는가는 브라우저가 책임진다. DOM 변경, CSS 속성 변경 → 개발자는 “적용된다”고 본다. 하지만 실제 반영 시점은 브라우저의 최적화 루틴에 따라 지연될 수 있다. 선언적 스타일 덕분에 개발자의 관점에서는 변화가 “즉시 적용되는 것처럼” 보이지만, 내부적으로 브라우저는 게으른(lazy) 방식으로 동작하여, 후속 API 호출이나 실제 화면 표시가 필요할 때까지 적용을 지연시킬 수 있다. 이는 성능 최적화(레이아웃 병합, repaint 지연 등)를 가능하게 한다.\n\n<br/>\n\n웹 브라우저를 단순히 “표시 도구”로 보지 않고, 제약 해결기(constraint solver) + 이벤트 루프 + 선언적 실행 환경이라는 큰 소프트웨어 아키텍처로 이해해야 한다.\n\n<br/>\n\nQ. 이 세 가지(제어 역전, 제약 프로그래밍, 선언적 프로그래밍)가 프론트엔드 프레임워크(React, Vue, Svelte 등)에 어떻게 계승·확장되었는지",
      "dateCreated": "2025-09-08",
      "dateUpdated": "2025-09-08"
    },
    {
      "id": "전역-상태-관리-라이브러리들",
      "title": "전역 상태관리 라이브러리 비교 (Redux, Tanstack Store, Zustand, Recoil)",
      "tags": [
        "react",
        "state-managemnet"
      ],
      "content": "상태 관리 라이브러리에 처음 입문한 것은 Redux였다. 당시에는 구조가 너무 복잡해 직접 그림을 그려가며 공부했던 기억이 있다. 이후 상태 관리 개념에 어느 정도 익숙해진 뒤부터는 주로 Zustand를 사용해왔다. Redux보다 초기 설정과 사용이 단순했고, 내 프로젝트에서는 무거운 상태를 다룰 일이 많지 않았기 때문에 훨씬 쾌적한 DX를 경험 할 수 있었다. Recoil도 사용했었지만, 내가 접한 시점에는 이미 deprecated 상태였기에 실질적으로는 Zustand를 주로 활용했다.\n\nTanstack Query를 알게 되고 나선, Tanstack 팀 레포지토리를 자주 들여다보고 있는데, Tanstack Store 라이브러리가 출시된 걸 보고 틈틈이 써보고 있다.\n\n리액트는 곧 상태라고 생각한다. 따라서 상태 관리가 핵심적인 주제이며, 그만큼 다양한 선택지가 존재하는 것 같다. 각 라이브러리의 철학, 장단점, 설정 방식, 활용 방법을 살펴보고 어떤 상황에서 어떤 라이브러리가 적합한지 나름의 정리를 해보고자 한다.\n\n<br/>\n\n## Redux(w. RTK)\n\n- 예측 가능하고 유지 관리 가능한 글로벌 상태 관리를 위한 JS 라이브러리\n- 예측 가능한 불변 업데이트, 단방향의 데이터 흐름, 순수 리듀서 함수\n- 상태, 액션, reducer, dispatch, store\n\n  • Flux 아키텍처와 Context API의 한계\n  • 서버 상태와 클라이언트 상태의 구분 (Tanstack Query의 철학적 기반)\n  • 상태 관리의 복잡도와 스케일에 따른 의사결정 기준\n  • React 18 이후 등장한 use 훅, 서버 컴포넌트와 상태 관리의 관계\n\n---\n\n### 참고\n\n- [Redux의 탄생동기와 철학 이해하기](https://jun-choi-4928.medium.com/redux의-탄생동기와-철학-이해하기-60eaa83e0b68)",
      "dateCreated": "2025-09-15",
      "dateUpdated": "2025-09-15"
    },
    {
      "id": "정규식",
      "title": "정규식",
      "tags": [],
      "content": "| 문법   | 의미                     |\n| ------ | ------------------------ |\n| .      | 임의의 문자 1개          |\n| \\d     | 숫자 (0-9)               |\n| \\w     | 영문, 숫자, 언더스코어   |\n| +      | 1개 이상 반복            |\n| ?      | 있거나 없음 (0 또는 1개) |\n| {n, m} | n개 이상 m 이하 반복     |\n| ^ $    | 문자열의 시작/끝         |\n| ( )    | 그룹 (캡처 및 재사용)    |\n\n- 간단한 패턴 매칭과 추출에 집중하고, 복잡한 로직은 일반 코드로 처리합니다.\n\n### 예시\n\n- 이메일\n  - `local parts` + @ + `domain` [^1]\n  - ID + at + 해당 ID를 발급한 메일 서버\n\n```javascript\n\n```\n\n[^1]: https://datatracker.ietf.org/doc/html/rfc5321",
      "dateCreated": "2026-01-19",
      "dateUpdated": "2026-01-19"
    },
    {
      "id": "튜플을-사용하는-이유",
      "title": "튜플을 사용하는 이유",
      "tags": [
        "python"
      ],
      "content": "튜플은 배열(list)과 딕셔너리(dict)와는 다른 역할과 성질을 갖는다.\n\n<br/>\n\n1. 불변성\n2. 이질적 데이터\n3. 성능 및 최적화\n4. 함수 반환값 패턴\n\n<br/>\n\n## 1. 불변성\n\n- 정의된 값은 수정이 불가능하다는 불변성 때문에 해시 가능(hashable)한 객체로 쓸 수 있다.\n- 덕분에 딕셔너리의 키나 집합의 원소로 사용할 수 있다.\n- 리스트는 불변적이지 않기 때문에 이 역할을 수행할 수 없다.\n\n<br/>\n\n## 2. 이질적 데이터 [^1]\n\n- 리스트는 동질적 데이터 집합을 다루는데 주로 쓰인다.\n  - 학생 점수 목록, 상품 ID 등\n- 반면 튜플은 이질적 데이터 구조를 표현하는데 적합하다.\n  - (이름, 나이, 직업)처럼 여러 속성이 묶인 하나의 레코드\n- 즉, 순서가 있는 불변 구조체로, 작은 데이터 구조체의 역할을 대신할 수 있다.\n\n<br/>\n\n## 3. 성능 및 최적화\n\n- 불변이라는 성질 때문에 리스트보다 메모리를 적게 쓰고, 접근 속도도 조금 더 빠르다.\n\n<br/>\n\n## 4. 함수 반환값 패턴\n\n- 함수에서 여러 값을 동시에 반환할 때 쓰이는 구조가 튜플이다.\n\n```python\ndef divide(a, b):\n    return a//b, a%b\n\n# 반환값: (a//b, a%b)\n```\n\n- 호출 시 자동으로 언패킹이 가능하여 (몫, 나머지)처럼 두 값이 명확하게 묶인다.\n\n[^1]: 동질적, 이질적: 데이터나 집단의 구성요소가 서로 같거나 다른 정도를 설명하는 개념. 이질적은 \"성질이 다른 것들로 이루어져 있다.\"를 의미한다.",
      "dateCreated": "2025-09-23",
      "dateUpdated": "2025-09-23"
    },
    {
      "id": "tag:react",
      "title": "#react"
    },
    {
      "id": "tag:note-vis",
      "title": "#note-vis"
    },
    {
      "id": "tag:BUGFIX",
      "title": "#BUGFIX"
    },
    {
      "id": "tag:tanstack-router",
      "title": "#tanstack-router"
    },
    {
      "id": "tag:about-me",
      "title": "#about-me"
    },
    {
      "id": "tag:css",
      "title": "#css"
    },
    {
      "id": "tag:pattern",
      "title": "#pattern"
    },
    {
      "id": "tag:anti",
      "title": "#anti"
    },
    {
      "id": "tag:code-smell",
      "title": "#code-smell"
    },
    {
      "id": "tag:불변성",
      "title": "#불변성"
    },
    {
      "id": "tag:web",
      "title": "#web"
    },
    {
      "id": "tag:web-rendering",
      "title": "#web-rendering"
    },
    {
      "id": "tag:markdown",
      "title": "#markdown"
    },
    {
      "id": "tag:parsing",
      "title": "#parsing"
    },
    {
      "id": "tag:python",
      "title": "#python"
    },
    {
      "id": "tag:페러다임",
      "title": "#페러다임"
    },
    {
      "id": "tag:state-managemnet",
      "title": "#state-managemnet"
    }
  ],
  "links": [
    {
      "source": "HOC",
      "target": "tag:react",
      "type": "tag"
    },
    {
      "source": "HTML-preview",
      "target": "tag:note-vis",
      "type": "tag"
    },
    {
      "source": "base-router-설정",
      "target": "tag:BUGFIX",
      "type": "tag"
    },
    {
      "source": "base-router-설정",
      "target": "tag:react",
      "type": "tag"
    },
    {
      "source": "base-router-설정",
      "target": "tag:tanstack-router",
      "type": "tag"
    },
    {
      "source": "cv",
      "target": "tag:about-me",
      "type": "tag"
    },
    {
      "source": "flex",
      "target": "tag:css",
      "type": "tag"
    },
    {
      "source": "god-object",
      "target": "단일 책임 원칙(SRP)",
      "type": "mention",
      "broken": true
    },
    {
      "source": "god-object",
      "target": "tag:pattern",
      "type": "tag"
    },
    {
      "source": "god-object",
      "target": "tag:anti",
      "type": "tag"
    },
    {
      "source": "god-object",
      "target": "tag:code-smell",
      "type": "tag"
    },
    {
      "source": "react-memo",
      "target": "useMemo",
      "type": "mention",
      "broken": true
    },
    {
      "source": "react-memo",
      "target": "useCallback",
      "type": "mention",
      "broken": true
    },
    {
      "source": "react-memo",
      "target": "tag:react",
      "type": "tag"
    },
    {
      "source": "react-memo",
      "target": "tag:불변성",
      "type": "tag"
    },
    {
      "source": "web-browser-engineering",
      "target": "선언적-웹-아키텍처",
      "type": "mention"
    },
    {
      "source": "web-browser-engineering",
      "target": "웹-페이지-다운로드",
      "type": "mention",
      "broken": true
    },
    {
      "source": "web-browser-engineering",
      "target": "tag:web",
      "type": "tag"
    },
    {
      "source": "web-browser-engineering",
      "target": "tag:web-rendering",
      "type": "tag"
    },
    {
      "source": "마크다운-문법",
      "target": "tag:note-vis",
      "type": "tag"
    },
    {
      "source": "마크다운-문법",
      "target": "tag:markdown",
      "type": "tag"
    },
    {
      "source": "마크다운-파싱-시스템",
      "target": "링크",
      "type": "mention",
      "broken": true
    },
    {
      "source": "마크다운-파싱-시스템",
      "target": "target",
      "type": "mention",
      "broken": true
    },
    {
      "source": "마크다운-파싱-시스템",
      "target": "wiki link",
      "type": "mention",
      "broken": true
    },
    {
      "source": "마크다운-파싱-시스템",
      "target": "link",
      "type": "mention",
      "broken": true
    },
    {
      "source": "마크다운-파싱-시스템",
      "target": "...",
      "type": "mention",
      "broken": true
    },
    {
      "source": "마크다운-파싱-시스템",
      "target": "\");\n    return i === -1 ? undefined : i;\n  },\n\n  // 실제 토큰화\n  tokenizer(src): WikiLinkToken",
      "type": "mention",
      "broken": true
    },
    {
      "source": "마크다운-파싱-시스템",
      "target": "React.memo",
      "type": "mention",
      "broken": true
    },
    {
      "source": "마크다운-파싱-시스템",
      "target": "tag:note-vis",
      "type": "tag"
    },
    {
      "source": "마크다운-파싱-시스템",
      "target": "tag:markdown",
      "type": "tag"
    },
    {
      "source": "마크다운-파싱-시스템",
      "target": "tag:parsing",
      "type": "tag"
    },
    {
      "source": "배열-튜플-딕셔너리",
      "target": "tag:python",
      "type": "tag"
    },
    {
      "source": "선언적-웹-아키텍처",
      "target": "tag:web",
      "type": "tag"
    },
    {
      "source": "선언적-웹-아키텍처",
      "target": "tag:페러다임",
      "type": "tag"
    },
    {
      "source": "전역-상태-관리-라이브러리들",
      "target": "tag:react",
      "type": "tag"
    },
    {
      "source": "전역-상태-관리-라이브러리들",
      "target": "tag:state-managemnet",
      "type": "tag"
    },
    {
      "source": "튜플을-사용하는-이유",
      "target": "tag:python",
      "type": "tag"
    }
  ]
}